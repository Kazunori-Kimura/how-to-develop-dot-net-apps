# 5. メンバーシップ フレームワークによる認証機能の実装 (前編)

## ASP.NETの認証機能について

### メンバーシップ フレームワーク

ASP.NET 2.0 以降から採用された認証ライブラリです。比較的シンプルに実装できるため、広く利用されています。  
今回はメンバーシップフレームワークによる認証・認可機能の実装方法を解説します。

<br>
<hr>
<br>

### 【用語解説】ASP.NET Identity

ASP.NET Identity は Visual Studio 2013 から新たに搭載された認証ライブラリです。

以下の様な特徴があります。

- Entity Framework を基板としているため、アカウント情報の管理に関する実装が容易である
- ActiveDirectoryによる認証に対応
- Twitter, Facebook, Googleなどのソーシャルアカウントによる認証に対応

Visual Studio 2013 で ASP.NETプロジェクトを作成するときに生成されるソースコードには、ASP.NET Identityによる認証機能が予め実装されています。

<br>
<hr>
<br>

## フォーム認証の実装

前回までに作成したアプリケーションに認証機能を実装していきます。

<br><br>

### 1. Providerクラスの実装

認証機能を司る *Provider* クラスを作成していきます。

<br>

### (1) *MembershipProvider* の実装

*MembershipProvider* クラスを継承したクラスを実装します。

幾つか *override* しないといけないメソッドがありますが、
今回使用するのは `ValidateUser` メソッドだけなので、
このメソッドのみ実装します。

* `ValidateUser` は `username` と `password` を受け取って認証の成否を返します。

認証の動作を確認するため、ひとまず `username` 、 `password` は固定としています。

<br>

`Models/CustomMembershipProvider.cs`

```cs
namespace TodoApp.Models
{
    public class CustomMembershipProvider : MembershipProvider
    {
        public override bool ValidateUser(string username, string password)
        {
            // とりあえず固定で認証
            if ("administrator".Equals(username) && "password".Equals(password))
            {
                return true;
            }
            if ("user".Equals(username) && "password".Equals(password))
            {
                return true;
            }
            return false;
        }
```

<br>

### (2) *RoleProvider* の実装

つづいて、 *RoleProvider* クラスを継承したクラスを実装します。

*MembershipProvider* と同様、今回使用するメソッドのみ
中身を実装します。

* `IsUserInRole` メソッドは 指定されたユーザーが、該当するロールに所属しているかどうかを返します。
* `GetRolesForUser` メソッドは 指定されたユーザーが所属するロールの配列を返します。

<br>

`Models/CustomRoleProvider.cs`

```cs
namespace TodoApp.Models
{
    public class CustomRoleProvider : RoleProvider
    {
        public override bool IsUserInRole(string username, string roleName)
        {
            if ("administrator".Equals(username) && "Administrators".Equals(roleName))
            {
                return true;
            }
            if ("user".Equals(username) && "Users".Equals(roleName))
            {
                return true;
            }
            return false;
        }

        public override string[] GetRolesForUser(string username)
        {
            if ("administrator".Equals(username))
            {
                return new string[] { "Administrators" };
            }
            return new string[] { "Users" };
        }
```

<br><br>

### 2. *LoginViewModel* の実装

ログイン画面の入力項目を *LoginViewModel* として
定義します。

<br>

`Models/LoginViewModel.cs`

```cs
namespace TodoApp.Models
{
    public class LoginViewModel
    {
        [Required]
        [DisplayName("ユーザー名")]
        public string UserName { get; set; }

        [Required]
        [DisplayName("パスワード")]
        public string Password { get; set; }
    }
}
```

<br>

### 3. Controllerの実装

### (1) *LoginController* の実装

`Controllers/LoginController.cs`

```cs
namespace TodoApp.Controllers
{
    [AllowAnonymous]
    public class LoginController : Controller
    {
        readonly CustomMembershipProvider membershipProvider = new CustomMembershipProvider();

        // GET: Login
        public ActionResult Index()
        {
            return View();
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Index([Bind(Include="UserName,Password")] LoginViewModel model)
        {
            if (ModelState.IsValid)
            {
                if (this.membershipProvider.ValidateUser(model.UserName, model.Password))
                {
                    FormsAuthentication.SetAuthCookie(model.UserName, false);
                    return RedirectToAction("Index", "Home");
                }
            }
            ViewBag.Message = "ログインに失敗しました。";
            return View(model);
        }

        public ActionResult SignOut()
        {
            FormsAuthentication.SignOut();
            return RedirectToAction("Index");
        }
    }
}
```

* `[AllowAnonymous]` は `LoginController` 全体へのアクセスで、認証を不要とします。
* `[HttpPost] Index` で認証処理を行います。

ログイン画面で入力された内容は `LoginViewModel` に
格納されます。

送られてきたユーザー名、パスワードを `MembershipProvider` でチェックし、認証OKであれば
`FormsAuthentication.SetAuthCookie` メソッドを実行します。

第2引数の boolean は、認証クッキーを残すかどうかのフラグです。
ログイン画面によくある、「次回から自動的にログイン」とか「ログインしたままにする」といったチェックボックスの機能です。

認証後、Home画面にリダイレクトしています。

* `SignOut` メソッドで認証クッキーが削除され、
ログアウトした状態となります。

<br>

### (2) 認証が必要なControllerの実装

`HomeController` と `DrugsController` にはすべてのユーザーがアクセス可能、
`ClassificationsController` には
`Administrators` のみがアクセス可能なように
実装します。

<br>

`Controllers/HomeController.cs`

```cs
namespace TodoApp.Controllers
{
    [Authorize]
    public class HomeController : Controller
    {
        // GET: Home
        public ActionResult Index()
        {
```

`[Authorize]` は `HomeController` にアクセスするために認証が必要であることを示します。

認証されていない状態でアクセスすると、ログイン画面にリダイレクトされます。

<br><br>

### (3) *ClassificationsController* の実装

例として、薬効分類のメンテナンスは *Administrators* の
ロールに所属しているユーザーのみ可能なように設定します。

`Controllers/ClassificationsController.cs`

```cs
namespace TodoApp.Controllers
{
    [Authorize(Roles="Administrators")]
    public class ClassificationsController : Controller
    {
        // GET: Admin
        public ActionResult Index()
        {
```

`[Authorize(Roles="Administrators")]` は `ClassificationsController` に `Administrators` ロールに属するユーザーのみアクセス可能であることを示します。

それ以外のユーザーが該当画面にアクセスした場合、
ログイン画面にリダイレクトされます。

<br>

今回は例としてコントローラー全体に対して
認証の設定を行いましたが、アクションメソッド単位で
制御することも可能です。

<br><br>

### 3. ログイン画面の作成

### *Login/Index.cshtml* の作成

* `LoginController`を右クリック -> `Add View` を選択
* `LoginViewModel` の `Create` として `Index.cshtml` を作成
* 不要な項目の削除 (フォームのタイトル部分)
* ボタンのラベルを `SignIn` に変更

<br>

`Views/Login/Index.cshtml`

```html
@model TodoApp.Models.LoginViewModel

@{
    ViewBag.Title = "Index";
}

<h2>SignIn</h2>

@using (Html.BeginForm())
{
    @Html.AntiForgeryToken()

    <div class="form-horizontal">
        @Html.ValidationSummary(true, "", new { @class = "text-danger" })
        <div class="form-group">
            @Html.LabelFor(model => model.UserName, htmlAttributes: new { @class = "control-label col-md-2" })
            <div class="col-md-10">
                @Html.EditorFor(model => model.UserName, new { htmlAttributes = new { @class = "form-control" } })
                @Html.ValidationMessageFor(model => model.UserName, "", new { @class = "text-danger" })
            </div>
        </div>

        <div class="form-group">
            @Html.LabelFor(model => model.Password, htmlAttributes: new { @class = "control-label col-md-2" })
            <div class="col-md-10">
                @Html.EditorFor(model => model.Password, new { htmlAttributes = new { @class = "form-control" } })
                @Html.ValidationMessageFor(model => model.Password, "", new { @class = "text-danger" })
            </div>
        </div>

        <div class="form-group">
            <div class="col-md-offset-2 col-md-10">
                <input type="submit" value="SignIn" class="btn btn-default" />
            </div>
        </div>
    </div>
}

<script src="~/Scripts/jquery-1.10.2.min.js"></script>
<script src="~/Scripts/jquery.validate.min.js"></script>
<script src="~/Scripts/jquery.validate.unobtrusive.min.js"></script>
```

<br><br>

### (2) *_Layout.cs* の修正

ナビゲーションバーに *ログアウト* のリンクを追加します。

`Views/Shared/_Layout.cshtml`

```html

```

`/Login/SignOut` へのリンクをナビゲーションバーに
追加しています。

<br><br>

### 4. web.configの設定

最後に、フォーム認証を行うように `web.config` に設定を追加します。

```xml
<system.web>
  <compilation debug="true" targetFramework="4.5.1"/>
  <httpRuntime targetFramework="4.5.1"/>
  <authentication mode="Forms">
    <forms loginUrl="~/Login/Index"></forms>
  </authentication>
  <membership defaultProvider="CustomMembershipProvider">
    <providers>
      <clear/>
      <add name="CustomMembershipProvider" type="TodoApp.Models.CustomMembershipProvider"/>
    </providers>
  </membership>
  <roleManager enabled="true" defaultProvider="CustomRoleProvider">
    <providers>
      <clear/>
      <add name="CustomRoleProvider" type="TodoApp.Models.CustomRoleProvider"/>
    </providers>
  </roleManager>
</system.web>
```

* `authentication` タグの追加
  - `mode="Forms"` でフォーム認証を行うことを指定
  - `forms` タグでログイン画面を指定
* `membership` タグの追加
  - `CustomMembershipProvider` クラスを指定
* `roleManager` タグの追加
  - `CustomRoleProvider` クラスを指定

<br><br>

デバッグ実行して動作確認を行います。
以下の通り動作を確認します。

* 認証を行わないとログイン画面以外のページが表示できないこと
* ログアウトのリンクをクリックするとログイン画面に戻ること
* *administrator* 以外のユーザーでは薬効分類のメンテナンス画面が表示できないこと

<br><br>

------

フォーム認証の実装方法について解説しました。

次回は以下の内容を取り上げます。

* ユーザーとロールの情報をデータベースで管理する
* ユーザー・ロールの管理画面の追加
* ロールによって画面表示を切り替える

<br><br>
